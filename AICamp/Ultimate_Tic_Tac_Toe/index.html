<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ultimate Tic-Tac-Toe</title>
  <style>
    :root{
      --bg:#0f1220;--panel:#151936;--panel-2:#1b2047;--text:#e7e9ff;--muted:#9aa1ff;--x:#6ee7ff;--o:#ffd166;--accent:#8b5cf6;--win:#22c55e;--tie:#64748b;--danger:#ef4444
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;background:radial-gradient(1200px 600px at 10% 0%,#121534 0,var(--bg) 60%),linear-gradient(180deg,#0b0e1c,#0f1220);color:var(--text);display:flex;min-height:100vh}
    .wrap{max-width:1100px;margin:auto;padding:24px;display:grid;gap:18px}
    header{display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:space-between}
    .title{font-weight:800;letter-spacing:.3px;font-size:clamp(18px,3vw,26px)}
    .controls{display:flex;gap:10px;flex-wrap:wrap}
    .btn, select{appearance:none;border:1px solid transparent;background:var(--panel);color:var(--text);padding:10px 14px;border-radius:14px;font-weight:600;cursor:pointer;transition:.2s}
    .btn:hover, select:hover{background:var(--panel-2)}
    .btn:active{transform:translateY(1px)}
    .note{color:var(--muted);font-size:14px}
    .board{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;padding:12px;background:linear-gradient(180deg,var(--panel),var(--panel-2));border-radius:18px;box-shadow:0 10px 25px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.05)}
    .local{position:relative;display:grid;grid-template-columns:repeat(3,1fr);aspect-ratio:1;border-radius:14px;overflow:hidden;background:#0c1029;box-shadow:inset 0 0 0 2px rgba(255,255,255,.06)}
    .local.active{box-shadow:0 0 0 3px var(--accent), inset 0 0 0 2px rgba(255,255,255,.06)}
    .local.won-x{background:linear-gradient(145deg, rgba(110,231,255,.18), rgba(110,231,255,.02));}
    .local.won-o{background:linear-gradient(145deg, rgba(255,209,102,.18), rgba(255,209,102,.02));}
    .local.tied{background:linear-gradient(145deg, rgba(148,163,184,.15), rgba(148,163,184,.02));}
    .cell{display:grid;place-items:center;border:1px solid rgba(255,255,255,.06);font-weight:900;font-size:clamp(16px,2.7vw,28px);cursor:pointer;user-select:none;transition:background .15s, transform .06s}
    .cell:hover{background:rgba(255,255,255,.04)}
    .cell:active{transform:scale(.98)}
    .cell.disabled{cursor:not-allowed;opacity:.45}
    .X{color:var(--x);text-shadow:0 0 20px rgba(110,231,255,.25)}
    .O{color:var(--o);text-shadow:0 0 20px rgba(255,209,102,.25)}
    .status{display:flex;align-items:center;gap:12px;padding:12px 14px;background:var(--panel);border-radius:14px;border:1px solid rgba(255,255,255,.06)}
    .pill{padding:6px 10px;border-radius:999px;font-weight:800}
    .pill.x{background:rgba(110,231,255,.12);color:var(--x);}
    .pill.o{background:rgba(255,209,102,.12);color:var(--o);}
    .pill.any{background:rgba(139,92,246,.15);color:var(--accent)}
    .hidden{display:none}
    footer{color:var(--muted);font-size:13px}
    .legend{display:flex;gap:8px;flex-wrap:wrap}
    .tag{background:rgba(255,255,255,.06);padding:6px 10px;border-radius:999px}
    .toast{position:fixed;right:16px;bottom:16px;background:var(--panel);border:1px solid rgba(255,255,255,.08);padding:10px 12px;border-radius:12px;opacity:0;transform:translateY(8px);transition:.25s}
    .toast.show{opacity:1;transform:none}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">Ultimate Tic‑Tac‑Toe</div>
      <div class="controls">
        <label class="note">Mode:
          <select id="mode">
            <option value="pvp">Two Players</option>
            <option value="bot">Vs Bot</option>
          </select>
        </label>
        <label class="note hidden" id="botSideWrap">Bot plays:
          <select id="botSide">
            <option value="2">O (second)</option>
            <option value="1">X (first)</option>
          </select>
        </label>
        <button class="btn" id="newGame">New Game</button>
      </div>
    </header>

    <div class="status" id="status">
      <div>Turn:</div>
      <div class="pill x" id="turnX">X</div>
      <div class="pill o hidden" id="turnO">O</div>
      <div style="margin-left:12px">Next board:</div>
      <div class="pill any" id="nextAny">Any</div>
      <div class="pill x hidden" id="nextX">X-board</div>
      <div class="pill o hidden" id="nextO">O-board</div>
      <div class="note" id="hint" style="margin-left:auto">Win by taking 3 local boards in a row.</div>
    </div>

    <div class="board" id="board"></div>

    <footer>
      <div class="legend">
        <span class="tag">Choose Two Players or Vs Bot</span>
        <span class="tag">Play sends your opponent to the matching mini-board</span>
        <span class="tag">If that board is finished/full → play anywhere</span>
        <span class="tag">Local win: 3 in a row (3 boxes)</span>
        <span class="tag">Global win: 3 local boards in a row</span>
      </div>
    </footer>

    <div class="toast" id="toast"></div>
  </div>

  <script>
    const WINS = [
      [0,1,2],[3,4,5],[6,7,8],
      [0,3,6],[1,4,7],[2,5,8],
      [0,4,8],[2,4,6]
    ];

    const state = {
      boards: Array.from({length:9}, ()=>Array(9).fill(0)),
      localWinners: Array(9).fill(0), // 0 none, 1 X, 2 O, 3 tie
      globalWinner: 0,
      current: 1, // 1 X, 2 O
      forcedBoard: -1, // -1 means any
      mode: 'pvp',
      botSide: 2,
      busy: false
    };

    const elBoard = document.getElementById('board');
    const elTurnX = document.getElementById('turnX');
    const elTurnO = document.getElementById('turnO');
    const elNextAny = document.getElementById('nextAny');
    const elNextX = document.getElementById('nextX');
    const elNextO = document.getElementById('nextO');
    const elMode = document.getElementById('mode');
    const elBotSideWrap = document.getElementById('botSideWrap');
    const elBotSide = document.getElementById('botSide');
    const elToast = document.getElementById('toast');

    function toast(t){
      elToast.textContent = t;
      elToast.classList.add('show');
      clearTimeout(elToast._t); elToast._t = setTimeout(()=>elToast.classList.remove('show'),1800);
    }

    function reset(){
      state.boards = Array.from({length:9}, ()=>Array(9).fill(0));
      state.localWinners = Array(9).fill(0);
      state.globalWinner = 0;
      state.current = 1;
      state.forcedBoard = -1;
      state.busy = false;
      render();
      maybeBot();
    }

    function render(){
      elBoard.innerHTML = '';
      state.localWinners.forEach((w,bi)=>{
        const local = document.createElement('div');
        local.className = 'local';
        if(state.globalWinner===0){
          const active = (state.forcedBoard===-1 && w===0) || (state.forcedBoard===bi && w===0);
          if(active) local.classList.add('active');
        }
        if(w===1) local.classList.add('won-x');
        else if(w===2) local.classList.add('won-o');
        else if(w===3) local.classList.add('tied');

        state.boards[bi].forEach((v,ci)=>{
          const cell = document.createElement('div');
          cell.className = 'cell';
          if(v===1){ cell.classList.add('X'); cell.textContent='X'; }
          if(v===2){ cell.classList.add('O'); cell.textContent='O'; }
          const playable = isPlayable(bi,ci);
          if(!playable) cell.classList.add('disabled');
          cell.addEventListener('click', ()=>onCell(bi,ci));
          local.appendChild(cell);
        });
        elBoard.appendChild(local);
      });

      // turn pills
      elTurnX.classList.toggle('hidden', state.current!==1);
      elTurnO.classList.toggle('hidden', state.current!==2);

      // next board pill(s)
      const fb = state.forcedBoard;
      elNextAny.classList.toggle('hidden', fb!==-1);
      elNextX.classList.add('hidden');
      elNextO.classList.add('hidden');
      if(fb!==-1){
        const w = state.localWinners[fb];
        if(w!==0) { // finished -> any
          elNextAny.classList.remove('hidden');
        } else {
          elNextAny.classList.add('hidden');
          (state.current===1?elNextX:elNextO).classList.remove('hidden');
        }
      }
    }

    function isPlayable(bi,ci){
      if(state.globalWinner!==0) return false;
      if(state.localWinners[bi]!==0) return false;
      if(state.boards[bi][ci]!==0) return false;
      if(state.forcedBoard===-1) return true;
      if(state.forcedBoard===bi) return true;
      // if forced board is finished/full, any
      const fb = state.forcedBoard;
      return state.localWinners[fb]!==0 || state.boards[fb].every(v=>v!==0);
    }

    function onCell(bi,ci){
      if(state.busy) return;
      if(!isPlayable(bi,ci)) return;
      if(state.globalWinner!==0) return;
      // place
      state.boards[bi][ci] = state.current;
      // check local
      const lw = checkLocalWinner(state.boards[bi]);
      if(lw!==0){ state.localWinners[bi] = lw; }
      else if(state.boards[bi].every(v=>v!==0)) { state.localWinners[bi] = 3; }
      // check global
      const gw = checkGlobalWinner();
      if(gw!==0){ state.globalWinner = gw; endGame(gw); render(); return; }
      // next forced board
      state.forcedBoard = ci;
      // if that board is finished or full -> any
      if(state.localWinners[ci]!==0 || state.boards[ci].every(v=>v!==0)) state.forcedBoard = -1;
      // swap player
      state.current = 3 - state.current;
      render();
      maybeBot();
    }

    function endGame(w){
      const msg = w===1 ? 'X takes three boards — X WINS!' : w===2 ? 'O takes three boards — O WINS!' : 'It\'s a TIE!';
      toast(msg);
    }

    function checkLocalWinner(board){
      for(const [a,b,c] of WINS){
        const v = board[a]; if(v!==0 && v===board[b] && v===board[c]) return v; // must fill 3 boxes in a row
      }
      return 0;
    }

    function checkGlobalWinner(){
      // Build a meta-board of winners: 0 none/ tie ignored for win, 1 X, 2 O
      const meta = state.localWinners.map(v => (v===1||v===2)?v:0);
      for(const [a,b,c] of WINS){
        const v = meta[a]; if(v!==0 && v===meta[b] && v===meta[c]) return v; // 3 boards in a row
      }
      // Optional full-board global tie (no more playable cells)
      const allDone = state.localWinners.every((w,i)=> w!==0 || state.boards[i].every(v=>v!==0));
      if(allDone) return 3; // tie
      return 0;
    }

    // --- Bot ---
    function maybeBot(){
      if(state.mode!=="bot") return;
      if(state.globalWinner!==0) return;
      if(state.current!==state.botSide) return;
      state.busy = true;
      setTimeout(()=>{ // slight delay for UX
        const move = chooseBotMove();
        state.busy = false;
        if(move) onCell(move.bi, move.ci);
      }, 220);
    }

    function legalMoves(){
      const moves=[];
      const fb = state.forcedBoard;
      const targetBoards = (fb===-1) ? [...Array(9).keys()].filter(b=>state.localWinners[b]===0 && !state.boards[b].every(v=>v!==0)) : [fb];
      for(const bi of targetBoards){
        state.boards[bi].forEach((v,ci)=>{ if(v===0) moves.push({bi,ci}); });
      }
      if(moves.length===0){ // if forced but dead, allow anywhere
        for(let bi=0; bi<9; bi++) if(state.localWinners[bi]===0)
          state.boards[bi].forEach((v,ci)=>{ if(v===0) moves.push({bi,ci}); });
      }
      return moves;
    }

    function chooseBotMove(){
      const me = state.botSide, opp = 3 - me;
      const moves = legalMoves();
      if(moves.length===0) return null;

      // 1) Win locally if possible
      for(const m of moves){
        const b = state.boards[m.bi].slice(); b[m.ci]=me; if(checkLocalWinner(b)===me) return m;
      }
      // 2) Block opponent's local win
      for(const m of moves){
        const b = state.boards[m.bi].slice(); b[m.ci]=opp; if(checkLocalWinner(b)===opp) return m;
      }
      // 3) Prefer sending opponent to an already finished board
      const prefer = moves.filter(m=>{
        const send = m.ci; return state.localWinners[send]!==0 || state.boards[send].every(v=>v!==0);
      });
      if(prefer.length) return prefer[Math.floor(Math.random()*prefer.length)];

      // 4) Otherwise, center > corners > sides within the target board
      const scoreCell = idx => [4,0,2,6,8,1,3,5,7].indexOf(idx); // lower is better
      moves.sort((a,b)=>scoreCell(a.ci)-scoreCell(b.ci));
      return moves[0];
    }

    // UI wiring
    document.getElementById('newGame').addEventListener('click', reset);
    elMode.addEventListener('change', e=>{
      state.mode = e.target.value; elBotSideWrap.classList.toggle('hidden', state.mode!=="bot"); reset();
    });
    elBotSide.addEventListener('change', e=>{ state.botSide = +e.target.value; reset(); });

    // init
    reset();
  </script>
</body>
</html>
